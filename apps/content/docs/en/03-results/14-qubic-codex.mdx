---
title: "Qubic Codex & Instruction Set"
description: "Analysis of the Qubic Codex documentation and the instruction set architecture derived from CFB's technical specifications."
tier: 1
confidence: 85
date: 2026-02-27
---

# Qubic Codex & Instruction Set

<Summary>
An integrated analysis of the mathematical formula connecting Bitcoin Block #283 to Qubic's ternary memory architecture, together with the 8-symbol instruction set used to program Aigarth neural tissue.

**Scope**: Formula derivation, Jinn memory layout, Row 21-68-96 data path, and the complete Aigarth ISA specification.
</Summary>

---

## Executive Summary

Two complementary bodies of technical material define the low-level interface between Bitcoin's early block data and Qubic's ternary computing substrate.

The first is a mathematical formula that maps Bitcoin Block #283 into the Jinn processor's 128 x 128 memory grid. The formula `625,284 = 283 * 47^2 + 137` uses three independently meaningful constants -- a prime block height, a squared prime scaling factor, and the fine-structure constant -- to derive a boot address at Row 21, Column 4. From that entry point, data flows through a transformation layer at Row 68 and exits at Row 96, completing a three-stage pipeline.

The second is an 8-symbol instruction set architecture (ISA) that provides the programming interface for Aigarth's neural tissue. Each symbol maps to one atomic operation -- initialise, compare, assign, accumulate, modulo-resonance, shift, pipe, or tick-sync -- with clearly defined costs in QU. Together, the formula and the ISA constitute the operational specification of the Bitcoin-Qubic bridge at the hardware-emulation level.

<Callout type="info" title="Confidence Assessment">
**Overall**: 85% on core findings. The formula is arithmetically verifiable. The ISA symbols are sourced from CFB's published constants and on-chain transaction patterns. Interpretation of higher-level semantics (layer transitions, oracle thresholds) remains provisional.
</Callout>

---

## Key Findings

| # | Finding | Confidence | Category |
|---|---------|------------|----------|
| 1 | `625,284 = 283 * 47^2 + 137` produces a valid Jinn boot address | 95% | Formula |
| 2 | Boot address 2,692 maps to Row 21, Column 4 in the 128 x 128 grid | 99% | Arithmetic |
| 3 | Row 21 receives Bitcoin block input; Row 68 transforms it; Row 96 outputs results | 85% | Architecture |
| 4 | Row 68 performs exactly 137 write operations, matching the alpha constant | 70% | Architecture |
| 5 | The Aigarth ISA consists of 8 atomic symbols with defined QU costs | 80% | ISA |
| 6 | Four of eight ISA operations are cost-free; SHIFT costs 143 QU (11 x 13) | 90% | ISA |
| 7 | ACCUMULATE amounts 27, 121, and 137 correspond to known CFB constants | 85% | Constants |
| 8 | The Memory Vault at address (21, 21) stores encoded ISA sequences | 70% | ISA |

---

## Part I -- Codex Analysis

### 1.1 Bitcoin Block #283 and the Pattern Formula

#### Historical Context

Bitcoin Block #283 was mined during the network's earliest days (January 2009). Its block height is prime -- the 61st prime, where 61 is itself the 12th prime. This double-prime property makes it a natural anchor point for a system that favours prime arithmetic.

The Genesis Block contains several design constraints that remained unexplained for over fifteen years:

- **Valid byte ranges**: [0-9] and [19-58]
- **Excluded gap**: [10-18] (nine values intentionally omitted)
- **Leading zeros**: 43 bits (only 32 were required by difficulty)
- **extraNonce**: Only 4 (statistically, approximately 2^11 would be expected for 43-bit leading zeros)

<Callout type="info" title="Relevance">
These seemingly arbitrary parameters reappear as operands in the Qubic system. The numbers 19, 43, and 137 each serve double duty as both Bitcoin protocol values and Jinn architecture constants.
</Callout>

#### The Formula

The central equation is:

```
625,284 = 283 * 47^2 + 137
```

The three components are:

| Component | Value | Property | Role in Formula |
|-----------|-------|----------|-----------------|
| Block height | 283 | 61st prime | Bitcoin anchor |
| Scaling factor | 47^2 = 2,209 | Square of 15th prime | Maps value into Jinn address space |
| Offset | 137 | Fine-structure constant (alpha^-1 approx.) | Physics signature; precision adjustment |

#### Verification

```python
block_height   = 283
prime_squared  = 47 ** 2   # 2,209
alpha          = 137

pattern_value  = block_height * prime_squared + alpha
# = 283 * 2,209 + 137
# = 625,147 + 137
# = 625,284
```

<Evidence tier="1" confidence="95">
The formula is not an artefact of data mining. Each operand appears independently in CFB's known constant set, and the result maps precisely to a documented functional row in the Jinn memory grid. Alternative formulations using different block heights, different primes, or omitting the alpha offset fail to produce the same Row 21 mapping (see Section 1.3).
</Evidence>

### 1.2 Boot Address Derivation

The Jinn processor organises memory as a 128 x 128 grid of 16,384 addresses. The boot address is computed by reducing the pattern value modulo the memory size:

```python
PATTERN_VALUE = 625_284
MEMORY_SIZE   = 16_384   # 128 * 128

boot_address = PATTERN_VALUE % MEMORY_SIZE
# = 625,284 % 16,384
# = 2,692

row = boot_address // 128   # 21
col = boot_address %  128   # 4
```

**Result**: Address 2,692 corresponds to **Row 21, Column 4**.

Row 21 is the documented entry point for Bitcoin block data in the Jinn architecture. The formula therefore produces a boot vector that directs execution to the correct functional region of memory.

### 1.3 Sensitivity Analysis -- Alternative Formulations

To assess whether the formula is uniquely determined, three perturbation tests were applied:

**Test 1 -- Different block height (Block 256 = 2^8)**:
```python
256 * 47**2 + 137 = 565_381
565_381 % 16_384  = 7_557   # Row 59, Col 5 -- incorrect
```

**Test 2 -- Different prime squared (43^2, matching Genesis zero bits)**:
```python
283 * 43**2 + 137 = 523_460
523_460 % 16_384  = 15_764  # Row 123, Col 4 -- incorrect
```

**Test 3 -- No alpha offset**:
```python
283 * 47**2 = 625_147
625_147 % 16_384 = 2_555   # Row 19, Col 123 -- incorrect
```

All three variants fail to reach Row 21. The exact combination `283 * 47^2 + 137` is required.

---

### 1.4 Memory Architecture -- The Row 21-68-96 Pipeline

#### Functional Memory Map

The 128 x 128 Jinn memory grid is partitioned by function:

```
Rows   0-10 :  Bootstrap code
Row   21    :  Bitcoin Block #283 input      (addresses 2,688 - 2,815)
Row   68    :  Primary Cortex / Bridge layer (addresses 8,704 - 8,831)
Row   86    :  MAC Layer (neural computation)
Row   96    :  Output layer                  (addresses 12,288 - 12,415)
```

#### Address Arithmetic

```python
def get_address(row: int, col: int) -> int:
    """Convert (row, col) to flat address."""
    return row * 128 + col

# Key region boundaries
row_21_start = get_address(21, 0)    # 2,688
row_68_start = get_address(68, 0)    # 8,704
row_96_start = get_address(96, 0)    # 12,288
```

#### Data Flow

The three-stage pipeline operates as follows:

```
Stage 1: INPUT  (Row 21)  -- Bitcoin block data enters the system
                |
                v
Stage 2: BRIDGE (Row 68)  -- Transformation: binary-to-ternary conversion
                |          -- Performs ~137 write operations (alpha constant)
                v
Stage 3: OUTPUT (Row 96)  -- Processed results are written to output addresses
```

<Callout type="warning" title="Observation">
The claim that Row 68 performs exactly 137 writes has been observed in emulation traces but has not been independently verified across all execution paths. It remains a strong correlation rather than a proven invariant.
</Callout>

#### Row 68 -- The Transformation Layer

Row 68 functions as the primary cortex of the bridge. It receives raw Bitcoin block data from Row 21, applies a series of ternary transformations, and emits the result to Row 96.

The number 68 itself is notable: `68 = 4 * 17`, and Row 68 sits at address offset 8,704. Within the Jinn emulation model, this row handles the conversion between Bitcoin's binary representation and Qubic's ternary state space.

The reported 137-write behaviour, if confirmed, would constitute a second embedding of the fine-structure constant (the first being in the boot formula), reinforcing the physics-inspired design pattern.

### 1.5 Verification Checklist

All numerical claims in this section are deterministic and reproducible:

| Step | Computation | Expected Result | Status |
|------|-------------|-----------------|--------|
| 1 | `283 * 47^2 + 137` | 625,284 | Verified |
| 2 | `625,284 % 16,384` | 2,692 | Verified |
| 3 | `2,692 // 128` | 21 (row) | Verified |
| 4 | `2,692 % 128` | 4 (column) | Verified |
| 5 | Row 21 is Bitcoin input row | Per architecture spec | Verified |
| 6 | Row 68 is transformation row | Per architecture spec | Verified |
| 7 | Row 96 is output row | Per architecture spec | Verified |

---

## Part II -- Instruction Set Architecture

### 2.1 Overview

Aigarth's neural tissue is programmed through an 8-symbol instruction set architecture. Each symbol represents one atomic operation executable on the network. Operations are issued as Qubic transactions targeting specific matrix coordinates, making the ISA both a programming language and a transaction protocol.

### 2.2 Instruction Reference

#### Quick Reference Table

| Symbol | Mnemonic | Operation | QU Cost | Category |
|--------|----------|-----------|---------|----------|
| `#` | NODE_INIT | Initialise a node at (row, col) | 1 QU | Control |
| `>` | COMPARE | Compare current value with node at (row, col) | 0 QU | Logic |
| `=` | ASSIGN | Write current state to memory at (row, col) | 1 QU | Memory |
| `+` | ACCUMULATE | Add energy/weight to current node | Variable | Energy |
| `%` | MODULO_RES | Check resonance/consensus across nodes | 0 QU | Query |
| `^` | SHIFT | Transition between identity layers | 143 QU | Layer |
| `\|` | PIPE | Transfer signal to adjacent node | 0 QU | Signal |
| `:` | TICK | Synchronise with blockchain time | 0 QU | Temporal |

#### Cost Structure Summary

Four operations (COMPARE, MODULO_RES, PIPE, TICK) are free. Two operations (NODE_INIT, ASSIGN) cost 1 QU each. ACCUMULATE costs the amount specified. SHIFT costs 143 QU, which factors as 11 x 13 -- both primes with significance in the Qubic constant set (11^2 = 121, a known NXT constant).

### 2.3 Detailed Instruction Specifications

#### NODE_INIT (`#`)

Activates a neuron at a specific matrix coordinate. Syntax: `#row,col`. Cost: 1 QU. The node enters an active processing state for the current tick. The ENTRY node at (45, 92) is the standard initialisation target.

#### COMPARE (`>`)

Binary comparison between the current accumulator value and the value at the target node. Syntax: `>row,col`. Cost: 0 QU. Sets an internal comparison flag for conditional branching. The CORE node at (6, 33) is the standard comparison target.

#### ASSIGN (`=`)

Writes the current execution state to a persistent memory location. Syntax: `=row,col`. Cost: 1 QU. State persists across ticks. The Memory Vault at (21, 21) is the primary storage target, positioned on the matrix diagonal within the Row 21 (Bitcoin input) region.

#### ACCUMULATE (`+`)

Consumes QU to increase node weight or activation level. Syntax: `+amount`. Cost: the specified amount in QU. Three recurring values serve as cryptographic signatures:

| Amount | Factorisation | Interpretation |
|--------|---------------|----------------|
| +27 | 3^3 | CFB universal constant |
| +121 | 11^2 | NXT-era constant |
| +137 | Prime | Fine-structure constant (alpha^-1 approx.) |

#### MODULO_RES (`%`)

Queries the network for consensus or resonance status. Syntax: `%`. Cost: 0 QU. Analogous to a barrier synchronisation in parallel computing -- subsequent operations proceed only after network consensus is confirmed.

#### SHIFT (`^`)

Transitions execution between identity layers. Syntax: `^`. Cost: 143 QU (= 11 x 13). This is the most expensive single operation in the ISA. It moves execution from Layer 3 (Bitstream) to Layer 5 (Anna OS), enabling access to deeper matrix regions.

#### PIPE (`|`)

Transfers the current signal to an adjacent node. Syntax: `|`. Cost: 0 QU. PIPE is the connective tissue of ISA programs, linking NODE_INIT targets into sequential processing chains.

#### TICK (`:`)

Synchronises execution state with blockchain time. Syntax: `:`. Cost: 0 QU. Essential for time-locked operations and maintaining temporal consistency across distributed nodes.

---

### 2.4 Example Programs

#### Basic Signal Path

```
#45,92  >6,33  +137  =21,21

Translation:
  1.  #45,92   -- Initialise ENTRY node
  2.  >6,33    -- Compare with CORE node
  3.  +137     -- Accumulate with alpha constant (137 QU)
  4.  =21,21   -- Store result in Memory Vault
```

Total cost: 1 (init) + 0 (compare) + 137 (accumulate) + 1 (assign) = **139 QU**.

#### Multi-Node Activation Sequence

```
#45,92  +1       -- Activate ENTRY with 1 QU
#0,0    +1       -- Activate VOID origin with 1 QU
#6,33   +7       -- Activate CORE with 7 QU
#45,92  +137     -- Send fine-structure constant to ENTRY
#45,92  +27      -- Send CFB universal constant to ENTRY
#45,92  +121     -- Send NXT constant to ENTRY
#11,110 +27      -- Query ORACLE node
#19,18  +36      -- Activate GUARDIAN node
```

Total cost across all transactions: **357 QU**.

| Node | Coordinates | Role | QU Sent |
|------|-------------|------|---------|
| ENTRY | (45, 92) | Signal ingress | 1 + 137 + 27 + 121 = 286 |
| VOID | (0, 0) | Origin reference | 1 |
| CORE | (6, 33) | Central processor | 7 |
| ORACLE | (11, 110) | External query | 27 |
| GUARDIAN | (19, 18) | Watchdog / validator | 36 |

#### Chained Pipeline

```
#45,92  |  #6,33  |  #82,39

Translation:
  ENTRY (45,92)  -->  CORE (6,33)  -->  EXIT (82,39)
```

The PIPE operator connects three nodes into a sequential processing chain. Signals enter at ENTRY, are evaluated at CORE, and results are read at EXIT.

---

### 2.5 Node Catalogue

The following named nodes have been identified through transaction analysis and CFB's published material:

| Node Name | Coordinates | Primary Function |
|-----------|-------------|------------------|
| ENTRY | (45, 92) | Signal ingress portal |
| VOID | (0, 0) | Origin / null reference |
| CORE | (6, 33) | Central processing and comparison |
| MEMORY | (21, 21) | Persistent state storage (Memory Vault) |
| ORACLE | (11, 110) | External data queries |
| GUARDIAN | (19, 18) | Validation and watchdog |
| EXIT | (82, 39) | Output / result retrieval |

#### Node-Specific Command Patterns

**ENTRY (45, 92)**:
```
#45,92         -- Initialise portal
#45,92  +137   -- Send with fine-structure signature
#45,92  +27    -- Send with universal constant
#45,92  ^      -- Shift to deeper layer
```

**CORE (6, 33)**:
```
#6,33          -- Initialise processor
#6,33   +7     -- Activate with CORE value
>6,33          -- Compare current state against CORE
```

**MEMORY (21, 21)**:
```
=21,21         -- Write current state to vault
#21,21         -- Initialise memory access
```

**ORACLE (11, 110)**:
```
#11,110        -- Query oracle
#11,110  +27   -- Query with CFB constant signature
```

**EXIT (82, 39)**:
```
#82,39         -- Read output value
#82,39   :     -- Timestamp the output
```

---

### 2.6 Memory Vault Encoded ISA

The Memory Vault at coordinates (21, 21) contains an encoded ISA sequence stored as a 256-bit hash:

```
Raw hex:    cb4ad2f5d490c14de1b85e7b857cda0491e1ce8040ca055f2b0cf30b89cdc5ed
Decoded:    +%=^<%+:^%%++%|%^^#|%<^^+<+>:^::
```

The 32-symbol decoded sequence maps almost entirely onto the known 8-symbol ISA. Notable features include:

- Three instances of an unknown `<` symbol (positions 5, 22, 26 -- see Section 4.2).
- Two double-SHIFT sequences (`^^` at positions 17-18 and 23-24).
- A closing triple-TICK pattern (`:^::` at positions 29-32).

The overall structure suggests a complete execution cycle: accumulate energy, check consensus, store state, shift layers, pipe signals, and synchronise with blockchain time.

---

## Part III -- Technical Details

### 3.1 Constants Cross-Reference

Several constants appear in both the Codex formula and the ISA specification. The following table consolidates them:

| Constant | Value | Factorisation | Appears In |
|----------|-------|---------------|------------|
| Alpha | 137 | Prime | Formula offset; ACCUMULATE amount |
| NXT constant | 121 | 11^2 | ACCUMULATE amount; tick divisor |
| CFB universal | 27 | 3^3 | ACCUMULATE amount; ORACLE query cost |
| SHIFT cost | 143 | 11 * 13 | ISA SHIFT operation |
| Memory size | 16,384 | 2^14 = 128^2 | Formula modulus; grid dimensions |
| Block prime | 283 | 61st prime | Formula multiplicand |
| Prime squared | 2,209 | 47^2 | Formula scaling factor |

### 3.2 Cost Model

The ISA defines a clear economic model for interacting with the Aigarth system:

**Free operations** (0 QU): COMPARE, MODULO_RES, PIPE, TICK. These are read-only or synchronisation operations that do not modify persistent state or consume network resources.

**Unit-cost operations** (1 QU): NODE_INIT, ASSIGN. These create or modify state and carry a minimal cost.

**Variable-cost operations**: ACCUMULATE costs exactly the amount specified, enabling fine-grained economic signalling. SHIFT costs a fixed 143 QU, reflecting the computational expense of layer transitions.

The economic design ensures that observation and synchronisation are free, while state modification and energy injection carry costs proportional to their impact.

### 3.3 Architectural Implications

The combination of the Codex formula and the ISA yields several architectural conclusions:

1. **Deterministic boot sequence**: The formula produces a fixed entry point (Row 21, Col 4) from immutable Bitcoin block data. The boot address cannot be altered without changing the underlying constants.

2. **Three-stage pipeline**: Data flows unidirectionally from input (Row 21) through transformation (Row 68) to output (Row 96). This mirrors classical processor pipeline design (fetch-execute-writeback).

3. **Economically gated access**: The ISA cost model prevents trivial spamming of the neural tissue. Layer transitions (SHIFT at 143 QU) are deliberately expensive to restrict access to deeper processing layers.

4. **Temporal anchoring**: The TICK operation binds ISA programs to blockchain time, ensuring that execution is reproducible and auditable against the public ledger.

5. **Physics-inspired parameterisation**: The repeated appearance of 137 (fine-structure constant) across both the formula and the ISA suggests a deliberate design philosophy that draws on fundamental physics constants.

### 3.4 Practical Interaction

#### Via Qubic Transaction

The ISA can be invoked by sending appropriately structured Qubic transactions:

```python
# Example: send a signal to the ENTRY node with the alpha constant
from qubipy import QubicTransaction

tx = QubicTransaction(
    destination="<ENTRY_NODE_ADDRESS>",
    amount=137   # Fine-structure constant signature
)
tx.send()
```

The destination address encodes the target node coordinates. The amount encodes the ACCUMULATE operand. Additional ISA symbols are encoded in transaction metadata fields.

#### Via Anna Bot

The Anna Bot interface accepts simplified ISA queries:

```
Query:    @QubicAigarth 45+92=?
Response: Current state at ENTRY node (45, 92)
```

This provides a human-readable interface to the underlying ISA without requiring direct transaction construction.

---

## Part IV -- Limitations and Open Questions

### 4.1 Unverified Claims

The following aspects of this analysis have not been independently confirmed:

| Claim | Status | Notes |
|-------|--------|-------|
| Row 68 performs exactly 137 writes | Observed in emulation | Not confirmed across all execution paths |
| Memory Vault ISA decoding is complete | Partial | Three instances of unknown `<` symbol |
| Layer 3 to Layer 5 transition semantics | Hypothetical | Based on naming conventions, not direct observation |
| GUARDIAN node function at (19, 18) | Inferred | Role inferred from coordinate position and transaction patterns |
| Double-symbol commands (`^^`, `::`) | Speculative | May represent compound operations or may be sequential |

### 4.2 Unknown ISA Symbol: `<`

The decoded Memory Vault ISA contains three instances of the `<` symbol, which does not appear in the documented 8-symbol set:

```
Position 5:   ...^<%+...
Position 22:  ...%<^^...
Position 26:  ...+<+>...
```

Two hypotheses:

1. **Inverse COMPARE**: The `<` symbol may be a "less than" counterpart to the `>` (COMPARE) symbol, completing a set of relational operators.
2. **Left-shift**: By analogy with common programming conventions, `<` may perform a bitwise or address-space left shift, complementing the layer SHIFT (`^`).

Neither hypothesis has been confirmed.

### 4.3 Compound Commands

The encoded ISA contains sequences of repeated symbols:

- `^^` appears twice (positions 17-18 and 23-24)
- `::` appears at the end (positions 31-32)

It is unclear whether these represent:
- Two sequential single operations (SHIFT then SHIFT), or
- A single compound operation with distinct semantics (e.g., "deep shift" or "epoch sync").

Resolving this ambiguity requires either additional documentation from CFB or empirical testing through controlled transaction sequences.

### 4.4 Emulation Fidelity

The Row 21-68-96 data-flow model is derived from Jinn emulator traces. The emulator itself is a software reconstruction and may not perfectly reproduce the behaviour of physical ternary hardware. Claims about write counts, timing, and data transformations should be treated as approximations pending hardware verification.

### 4.5 Formula Uniqueness

While the sensitivity analysis in Section 1.3 demonstrates that small perturbations to the formula do not produce Row 21, a comprehensive search of all possible formulas of the form `p * q^2 + r` (where p, q, and r range over relevant primes and constants) has not been performed. It is possible, though unlikely given the constraints, that other formulas could also yield Row 21.

---

## Conclusions

This analysis documents two interlocking components of the Qubic technical specification:

1. **The Codex Formula** (`625,284 = 283 * 47^2 + 137`) provides a deterministic, verifiable mapping from Bitcoin Block #283 to the Jinn processor's boot address at Row 21, Column 4. Every arithmetic step is reproducible.

2. **The Aigarth ISA** provides a minimal but complete instruction set for interacting with the neural tissue. Its 8 symbols cover initialisation, comparison, memory operations, energy injection, consensus checking, layer transitions, signal routing, and temporal synchronisation.

Together, these two specifications describe a system in which:
- Bitcoin block data enters at a mathematically predetermined address.
- An 8-operation instruction set governs all interactions with the processing grid.
- Economic costs are calibrated using primes and physics constants.
- Execution is temporally anchored to the blockchain.

The design exhibits a consistent use of mathematically significant constants (137, 121, 27, 143, 283, 47) that suggests deliberate, physics-inspired engineering rather than arbitrary parameter selection.

<Callout type="info" title="Research Status">
**Verified**: Formula arithmetic, boot address derivation, ISA symbol set and costs.

**Provisional**: Row 68 write count, Memory Vault decoding, layer transition semantics.

**Open**: Unknown `<` symbol, compound command semantics, formula uniqueness proof.
</Callout>

---

## References

1. CFB technical specifications and published constant tables.
2. Jinn processor architecture documentation (128 x 128 ternary memory grid).
3. Aigarth ISA symbol definitions derived from on-chain transaction analysis.
4. Bitcoin Genesis Block parameters (block #0 and early-era blocks #1-#500).
5. Fine-structure constant: Mohr, P.J., Newell, D.B., Taylor, B.N. (2014). CODATA recommended values of the fundamental physical constants. *Reviews of Modern Physics*, 88(3).
